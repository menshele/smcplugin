{
  parserClass="com.smcplugin.parser.SmcParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Smc"
  psiImplClassSuffix="Impl"
  psiPackage="com.smcplugin.psi"
  psiImplPackage="com.smcplugin.psi.impl"

  elementTypeHolderClass="com.smcplugin.psi.SmcTypes"
  elementTypeClass="com.smcplugin.psi.SmcElementType"
  tokenTypeClass="com.smcplugin.psi.SmcTokenType"

  psiImplUtilClass="com.smcplugin.psi.impl.SmcPsiImplUtil"

  tokens = [
      VERBATIM_OPEN="%{"
      VERBATIM_CLOSE="%}"
      CLASS_KEYWORD="%class"
      PACKAGE_KEYWORD="%package"
      FSM_CLASS_KEYWORD="%fsmclass"
      FSM_FILE_KEYWORD="%fsmfile"
      ACCESS_KEYWORD="%access"
      HEADER_KEYWORD="%header"
      DECLARE_KEYWORD="%declare"
      IMPORT_KEYWORD="%import"
      INCLUDE_KEYWORD="%include"
      START_KEYWORD="%start"
      MAP_KEYWORD="%map"
      BRACE_OPEN="{"
      BRACE_CLOSE="}"
      PARENTHESES_OPEN="("
      PARENTHESES_CLOSE=")"
      ENTRY_KEYWORD="Entry"
      EXIT_KEYWORD="Exit"
      BRACKET_OPEN="["
      BRACKET_CLOSE="]"

      COLON=":"
      COMMA=","
      SEMICOLON=";"
      POP_KEYWORD="pop"
      PUSH_KEYWORD="push"
      ASSIGN_OP="="
      NIL_KEYWORD="nil"
      SLASH_SIGN="/"
     ]
}

fsmFile ::= (verbatim_code_section|class_name| start_state|fsm_class|fsm_file| header_file| include_file|
package_name| import_class| declare| access| map+|LINE_COMMENT|BLOCK_COMMENT|CRLF)*

fsm_file ::= FSM_FILE_KEYWORD FSM_FILE_NAME

fsm_class ::= FSM_CLASS_KEYWORD FSM_CLASS_NAME

verbatim_code_section::= VERBATIM_OPEN VERBATIM_CODE? VERBATIM_CLOSE

start_state ::= START_KEYWORD START_STATE_NAME

class_name ::= CLASS_KEYWORD CONTEXT_CLASS_NAME

header_file ::= HEADER_KEYWORD HEADER_FILE_NAME

include_file ::= INCLUDE_KEYWORD INCLUDE_FILE_NAME

package_name ::= PACKAGE_KEYWORD PACKAGE_STATEMENT

import_class ::= IMPORT_KEYWORD STATIC_JAVA_KEYWORD? IMPORT_CLASS_STATEMENT

declare ::= DECLARE_KEYWORD DECLARE_STATEMENT

access ::= ACCESS_KEYWORD ACCESS_LEVEL

map ::= MAP_KEYWORD MAP_NAME MAP_SECTION_BOUND states MAP_SECTION_BOUND {pin=1}

states ::= state*

state ::=STATE_NAME ((entry exit)|(exit entry)|((entry|exit)?))? BRACE_OPEN transitions BRACE_CLOSE {pin=1}

transitions ::= transition*

transition ::= TRANSITION_NAME transition_args? guard? next_state BRACE_OPEN actions BRACE_CLOSE {pin=1}

entry ::= ENTRY_KEYWORD BRACE_OPEN actions BRACE_CLOSE {pin=1}

exit ::= EXIT_KEYWORD BRACE_OPEN actions BRACE_CLOSE {pin=1}

transition_args ::= PARENTHESES_OPEN parameters PARENTHESES_CLOSE {pin=1}

parameters ::= parameter COMMA parameters | parameter

parameter ::= PARAMETER_NAME COLON PARAMETER_TYPE

guard ::= BRACKET_OPEN GUARD_RAW_CODE BRACKET_CLOSE

//TODO: Need to implement push/pop transitions
next_state ::= NEXT_STATE_NAME |
              NIL_KEYWORD|
              push_transition |
              pop_transition

push_transition ::= WORD SLASH_SIGN PUSH_KEYWORD PARENTHESES_OPEN WORD PARENTHESES_CLOSE |
                   NIL_KEYWORD SLASH_SIGN PUSH_KEYWORD PARENTHESES_OPEN WORD PARENTHESES_CLOSE |
                   PUSH_KEYWORD PARENTHESES_OPEN WORD PARENTHESES_CLOSE

pop_transition ::= POP_KEYWORD |
                  POP_KEYWORD PARENTHESES_OPEN WORD? PARENTHESES_CLOSE |
                  POP_KEYWORD PARENTHESES_OPEN WORD COMMA pop_arguments* PARENTHESES_CLOSE

pop_arguments ::= POP_ARGUMENT_RAW_CODE |
                 POP_ARGUMENT_RAW_CODE COMMA pop_arguments

actions ::= action actions|action?



action ::= ACTION_NAME PARENTHESES_OPEN arguments? PARENTHESES_CLOSE SEMICOLON {pin=1}

arguments ::= ARGUMENT_STATEMENT COMMA arguments|ARGUMENT_STATEMENT {pin=1}
