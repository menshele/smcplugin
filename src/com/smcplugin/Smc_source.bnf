{
  parserClass="com.smcplugin.parser.SmcParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Smc"
  psiImplClassSuffix="Impl"
  psiPackage="com.smcplugin.psi"
  psiImplPackage="com.smcplugin.psi.impl"

  elementTypeHolderClass="com.smcplugin.psi.SmcTypes"
  elementTypeClass="com.smcplugin.psi.SmcElementType"
  tokenTypeClass="com.smcplugin.psi.SmcTokenType"

  psiImplUtilClass="com.smcplugin.psi.impl.SmcPsiImplUtil"



  tokens = [
      VERBATIM_OPEN="%{"
      VERBATIM_CLOSE="%}"
      CLASS_KEYWORD="%class"
      PACKAGE_KEYWORD="%package"
      FSM_CLASS_KEYWORD="%fsmclass"
      FSM_FILE_KEYWORD="%fsmfile"
      ACESS_KEYWORD="%access"
      START_KEYWORD="%start"
      MAP_KEYWORD="%map"

      MAP_SECTION_OPEN="%%"
      MAP_SECTION_CLOSE="%%"

      space='regexp:\s+'
      id="regexp:\w+"
      string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\\"|\\\'|\\)*\")"
      number="regexp:\d+"
      number="regexp:.*"

      WORD = "regexp:[A-Za-z][A-Za-z0-9_.]*' | '_regexp:[A-Za-z][A-Za-z0-9_.]*"
// Reads in code verbatim until end-of-line is reached.
      RAW_CODE_LINE = 'regexp.*' '\n\r\f'

// Read in code verbatim.
      RAW_CODE = 'regexp:.*|\n\r\f'
      LINE_COMMENT="regexp://.*"
      BLOCK_COMMENT="regexp:/\*(.|\n)*\*/"
       RAW_CODE = 'regexp:\{((.||\n\r\f)*?)\}'
    ]
}

fsmFile ::= source? start_state class_name header_file? include_file*
package_name* class_import* declare* access* map+|LINE_COMMENT|BLOCK_COMMENT

source ::= '%{' RAW_CODE '%}' {pin=1 recoverWhile=source_recover}

source_recover::=('%}')

start_state ::= '%start' WORD '\n\r\f' {pin=2 recoverWhile=start_state_recover}

start_state_recover ::= ('\n\r\f')

class_name ::= '%class' WORD

header_file ::= '%header' RAW_CODE_LINE

include_file ::= '%include' RAW_CODE_LINE

package_name ::= '%package' WORD

class_import ::= '%import' RAW_CODE_LINE

declare ::= '%declare' RAW_CODE_LINE

access ::= '%access' RAW_CODE_LINE

map ::= '%map' WORD '%%' states '%%'

states ::= WORD entry? exit? '{' transition* '}'

entry ::= 'Entry {' actions* '}'

exit ::= 'Exit {' actions '}'

transition ::= WORD transition_args? guard? next_state '{' actions '}' {mixin="com.smcplugin.psi.impl.SmcNamedElementImpl"
implements="com.smcplugin.psi.SmcNamedElement" methods=[getName setName getNameIdentifier]}

transition_args ::= '(' parameters ')'

parameters ::= parameter |
              parameter ',' parameters

parameter ::= WORD ':' RAW_CODE

guard ::= '[' RAW_CODE ']'

next_state ::= WORD |
              'nil' |
              push_transition |
              pop_transition

push_transition ::= WORD '/' 'push(' WORD ')' |
                   'nil/push(' WORD ')' |
                   'push(' WORD ')'

pop_transition ::= 'pop' |
                  'pop(' WORD? ')' |
                  'pop(' WORD ',' pop_arguments* ')'

pop_arguments ::= RAW_CODE |
                 RAW_CODE ',' pop_arguments

actions ::= dotnet_assignment |
           action |
           action actions

dotnet_assignment ::= WORD '=' RAW_CODE ';'

action ::= WORD '(' arguments* ');'

arguments ::= RAW_CODE |
             RAW_CODE ',' arguments


/*WORD ::= 'regexp:[A-Za-z][A-Za-z0-9_.]*' |
        '_regexp:[A-Za-z][A-Za-z0-9_.]*'*/
// Reads in code verbatim until end-of-line is reached.

//RAW_CODE_LINE ::= 'regexp.*' '\n\r\f'

// Read in code verbatim.
//RAW_CODE ::= 'regexp:.*|\n\r\f'

// Both the // and /* */ comment types are supported.
// Note: SMC honors nested /* */ comments.
//LINE_COMMENT ::= 'regexp://.*'
//%{
